#!/usr/bin/env python3
"""
Render environment files for Docker, backend, and frontend from deployment/config.toml.

Keeping all credentials in a single TOML file lets us hand over a true one-click
deployment package. This helper fans those values out to the various `.env` files
without ever committing secrets to git.
"""

from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path
from textwrap import dedent

try:  # Python 3.11+
    import tomllib  # type: ignore[attr-defined]
except ModuleNotFoundError:  # pragma: no cover - fallback for older interpreters
    import tomli as tomllib  # type: ignore[import]


def load_config(path: Path) -> dict:
    if not path.exists():
        raise FileNotFoundError(f"Config file not found: {path}")
    with path.open("rb") as fh:
        return tomllib.load(fh)


def build_env_map(cfg: dict) -> dict:
    env_map: dict[str, str] = {}

    app = cfg.get("app", {})
    db = cfg.get("database", {})
    aws = cfg.get("aws", {})
    openai = cfg.get("openai", {})
    agora = cfg.get("agora", {})
    m_tts = cfg.get("microsoft_tts", {})
    eleven = cfg.get("elevenlabs", {})
    frontend = cfg.get("frontend", {})
    docker_cfg = cfg.get("docker", {})

    db_name = db.get("name", "training_system")
    db_user = db.get("user", "postgres")
    db_password = db.get("password", "postgres")
    db_host = db.get("host", "postgres")
    db_port = str(db.get("port", 5432))
    db_driver = db.get("driver", "postgresql+psycopg")

    env_map["POSTGRES_DB"] = db_name
    env_map["POSTGRES_USER"] = db_user
    env_map["POSTGRES_PASSWORD"] = db_password
    env_map["POSTGRES_HOST"] = db_host
    env_map["POSTGRES_PORT"] = db_port
    env_map["DATABASE_URL"] = f"{db_driver}://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}"

    env_map["SECRET_KEY"] = app.get("secret_key", "")
    env_map["ALGORITHM"] = app.get("algorithm", "HS256")
    env_map["ACCESS_TOKEN_EXPIRE_MINUTES"] = str(app.get("access_token_expire_minutes", 1440))
    cors_origins = app.get("cors_origins", ["http://localhost:5173"])
    env_map["CORS_ORIGINS"] = json.dumps(cors_origins)

    env_map["AWS_ACCESS_KEY_ID"] = aws.get("access_key_id", "")
    env_map["AWS_SECRET_ACCESS_KEY"] = aws.get("secret_access_key", "")
    bucket_name = aws.get("bucket_name", "")
    env_map["AWS_BUCKET_NAME"] = bucket_name
    env_map["AWS_S3_BUCKET"] = bucket_name  # backwards compatibility
    env_map["AWS_REGION"] = aws.get("region", "us-east-1")

    env_map["OPENAI_API_KEY"] = openai.get("api_key", "")

    env_map["AGORA_APP_ID"] = agora.get("app_id", "")
    env_map["AGORA_APP_CERTIFICATE"] = agora.get("app_certificate", "")
    env_map["AGORA_CUSTOMER_ID"] = agora.get("customer_id", "")
    env_map["AGORA_CUSTOMER_SECRET"] = agora.get("customer_secret", "")
    env_map["AGORA_PROJECT_ID"] = agora.get("project_id", "")
    env_map["AGORA_CONVO_AI_BASE_URL"] = agora.get(
        "convo_ai_base_url",
        "https://api.agora.io/api/conversational-ai-agent/v2/projects",
    )
    env_map["AGORA_AGENT_UID"] = str(agora.get("agent_uid", 999))

    env_map["MICROSOFT_TTS_KEY"] = m_tts.get("key", "")
    env_map["MICROSOFT_TTS_REGION"] = m_tts.get("region", "")

    env_map["ELEVENLABS_API_KEY"] = eleven.get("api_key", "")
    env_map["ELEVENLABS_VOICE_ID"] = eleven.get("voice_id", "")
    env_map["ELEVENLABS_MODEL_ID"] = eleven.get("model_id", "eleven_flash_v2_5")

    env_map["FRONTEND_API_BASE_URL"] = frontend.get("api_base_url", "http://localhost:8000")
    env_map["DEBIAN_APT_MIRROR"] = docker_cfg.get("apt_mirror", "")

    return env_map


def build_frontend_env(env_map: dict) -> dict:
    return {
        "VITE_API_URL": env_map.get("FRONTEND_API_BASE_URL", "http://localhost:8000"),
        "VITE_AGORA_APP_ID": env_map.get("AGORA_APP_ID", ""),
    }


def write_env_file(env_map: dict, output_path: Path) -> None:
    output_path.parent.mkdir(parents=True, exist_ok=True)
    lines = [
        "# Auto-generated by deployment/render_env.py.",
        "# Do not edit this file manually; update deployment/config.toml instead.",
        "",
    ]
    for key, value in env_map.items():
        sanitized = "" if value is None else str(value)
        lines.append(f"{key}={sanitized}")

    output_path.write_text("\n".join(lines) + "\n")


def write_frontend_env(frontend_env: dict, output_path: Path) -> None:
    output_path.parent.mkdir(parents=True, exist_ok=True)
    lines = [
        "# Auto-generated by deployment/render_env.py.",
        "# Vite dev server reads these values.",
        "",
    ]
    for key, value in frontend_env.items():
        sanitized = "" if value is None else str(value)
        lines.append(f"{key}={sanitized}")

    output_path.write_text("\n".join(lines) + "\n")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Render environment files from deployment/config.toml"
    )
    parser.add_argument(
        "--config",
        type=Path,
        default=Path("deployment/config.toml"),
        help="Path to deployment config file (default: deployment/config.toml)",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path(".env"),
        help="Path to write the docker-compose .env file (default: .env)",
    )
    parser.add_argument(
        "--backend-env",
        type=Path,
        help="Optional path to also write a backend .env for local FastAPI development (e.g. backend/.env)",
    )
    parser.add_argument(
        "--frontend-env",
        type=Path,
        help="Optional path to also write a frontend .env for the Vite dev server (e.g. frontend/.env)",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    try:
        cfg = load_config(args.config)
    except FileNotFoundError as exc:
        print(exc, file=sys.stderr)
        return 1

    env_map = build_env_map(cfg)
    frontend_env = build_frontend_env(env_map)

    write_env_file(env_map, args.output)

    if args.backend_env:
        write_env_file(env_map, args.backend_env)

    if args.frontend_env:
        write_frontend_env(frontend_env, args.frontend_env)

    generated_paths = [str(args.output)]
    if args.backend_env:
        generated_paths.append(str(args.backend_env))
    if args.frontend_env:
        generated_paths.append(str(args.frontend_env))
    paths_block = "\n".join(f"- {path}" for path in generated_paths)

    print(
        dedent(
            f"""
            Generated environment files from {args.config}:
            {paths_block}
            """
        ).strip()
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
